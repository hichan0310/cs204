# Chapter 3: 알고리즘

## 3.1 알고리즘

**알고리즘**이란 **계산을 수행**하거나 **문제를 해결**하기 위한 **유한한 단계**의 **정확한 명령어** 모음입니다.

### 예시: 정수 시퀀스에서 최대값 찾기

정수 시퀀스에서 최대값을 찾는 알고리즘은 다음과 같이 수행됩니다:

1. 임시 최대값을 첫 번째 정수로 설정.
2. 다음 정수를 임시 최대값과 비교.
3. 비교한 값이 임시 최대값보다 크면, 임시 최대값을 해당 값으로 변경.
4. 더 비교할 값이 있으면 2단계로 돌아가고, 없으면 종료.
5. 종료 시 임시 최대값이 시퀀스의 최대값입니다.

### Pseudocode: 최대값 찾기 알고리즘

```R
procedure max(a₁, a₂, ..., aₙ: integers)
    max := a₁
    for i := 2 to n
        if max < aᵢ then
            max := aᵢ
    return max
```

### 알고리즘의 속성

- **입력 (Input)**: 알고리즘은 정의된 집합에서 입력값을 받습니다.
- **출력 (Output)**: 입력값을 처리하여 결과를 반환합니다.
- **정확성 (Correctness)**: 모든 입력값에 대해 정확한 결과를 반환해야 합니다.
- **유한성 (Finiteness)**: 알고리즘은 유한한 단계 내에 결과를 도출해야 합니다.

## 3.2 탐색 문제

**탐색 문제**는 리스트에서 특정 요소를 찾는 문제입니다. 예를 들어, 리스트 $a_1, a_2, ..., a_n$에서 특정 값 $x$를 찾는 것이 목표입니다.

### 선형 탐색 (Linear Search)

선형 탐색은 리스트의 첫 번째 요소부터 차례로 값을 비교하며 목표값을 찾습니다.

#### Pseudocode: 선형 탐색 알고리즘

```r
procedure linear_search(x: integer, a₁, a₂, ..., aₙ: distinct integers)
    i := 1
    while (i ≤ n and x ≠ aᵢ)
        i := i + 1
    if i ≤ n then
        location := i
    else
        location := 0
    return location
```

### 이진 탐색 (Binary Search)

이진 탐색은 **정렬된 리스트**에서 중간값을 기준으로 탐색 범위를 절반으로 줄여가며 값을 찾습니다.

#### Pseudocode: 이진 탐색 알고리즘

```r
procedure binary_search(x: integer, a₁, a₂, ..., aₙ: increasing integers)
    i := 1      {i는 탐색 범위의 왼쪽 끝}
    j := n      {j는 탐색 범위의 오른쪽 끝}
    while i ≤ j do
        m := ⌊(i + j) / 2⌋  {중간 인덱스}
        if aₘ = x then
            return m
        else if aₘ < x then
            i := m + 1
        else
            j := m - 1
    return 0
```

### 이진 탐색 예시

$19$를 찾기 위한 이진 탐색 과정을 다음과 같이 진행할 수 있습니다.

#### 초기 리스트
$1, 2, 3, 5, 6, 7, 8, 10, 12, 13, 15, 16, 18, 19, 20, 22$

1. 중간값은 $10$, $19 > 10$이므로 오른쪽 절반 탐색.
2. 현재 리스트는 $12, 13, 15, 16, 18, 19, 20, 22$. 중간값은 $16$, $19 > 16$이므로 다시 오른쪽 절반 탐색.
3. 현재 리스트는 $18, 19, 20, 22$. 중간값은 $19$, $19 = 19$이므로 위치를 반환합니다.

## 3.3 정렬 문제

**정렬 문제**는 리스트의 요소들을 오름차순 또는 내림차순으로 배열하는 문제입니다. 다양한 정렬 알고리즘들이 존재하며, **버블 정렬(Bubble Sort)**과 **삽입 정렬(Insertion Sort)** 등의 알고리즘이 있습니다.

### 버블 정렬 (Bubble Sort)

버블 정렬은 인접한 두 요소를 비교하여 잘못된 순서에 있는 경우 위치를 바꿉니다. $n$개의 요소에 대해 $n-1$번의 패스를 진행합니다.

#### Pseudocode: 버블 정렬 알고리즘

```r
procedure bubble_sort(a₁, a₂, ..., aₙ: real numbers)
    for i := 1 to n-1
        for j := 1 to n-i
            if aⱼ > aⱼ₊₁ then
                swap(aⱼ, aⱼ₊₁)
```

### 삽입 정렬 (Insertion Sort)

삽입 정렬은 정렬되지 않은 요소를 이미 정렬된 부분 리스트에 삽입하는 방식입니다.

#### Pseudocode: 삽입 정렬 알고리즘

```r
procedure insertion_sort(a₁, a₂, ..., aₙ: real numbers)
    for j := 2 to n
        key := aⱼ
        i := j - 1
        while i > 0 and aᵢ > key
            aᵢ₊₁ := aᵢ
            i := i - 1
        aᵢ₊₁ := key
```

## 3.4 탐욕 알고리즘 (Greedy Algorithms)

탐욕 알고리즘은 **최적화 문제**에서 **현재 단계**에서 최적의 선택을 하며 해결해 나가는 방식입니다. 이는 반드시 **전역 최적화**를 보장하지 않지만, 여러 문제에서 효율적인 방법이 될 수 있습니다.

### 예시: 동전 교환 문제

$n$ 센트의 거스름돈을 최소한의 동전으로 만드는 알고리즘을 작성해보겠습니다. 동전의 종류는 25, 10, 5, 1 센트입니다.

#### Pseudocode: 탐욕 알고리즘

```r
procedure change(n: integer)
    d₁ := 0  {25 센트 동전 개수}
    d₂ := 0  {10 센트 동전 개수}
    d₃ := 0  {5 센트 동전 개수}
    d₄ := 0  {1 센트 동전 개수}

    while n ≥ 25
        d₁ := d₁ + 1
        n := n - 25
    while n ≥ 10
        d₂ := d₂ + 1
        n := n - 10
    while n ≥ 5
        d₃ := d₃ + 1
        n := n - 5
    while n ≥ 1
        d₄ := d₄ + 1
        n := n - 1

    return (d₁, d₂, d₃, d₄)
```

### 최적성 증명

미국 동전으로 구성된 거스름돈을 가장 적은 개수의 동전으로 만드는 탐욕 알고리즘의 최적성을 다음과 같이 증명할 수 있습니다.

#### 정리: 탐욕 알고리즘이 최소 동전 수를 반환함

증명: $n$ 센트의 거스름돈을 주어진 동전들(25, 10, 5, 1 센트)로 최소한의 동전 개수를 사용하여 구성할 수 있습니다.

1. 먼저, 주어진 금액에서 가능한 가장 큰 동전을 선택합니다. 예를 들어, 67 센트를 거슬러 줄 때 먼저 25 센트 동전을 선택하면, 남은 금액은 42 센트입니다.
2. 다시 가장 큰 동전을 선택합니다. 42 센트에서 25 센트를 선택하면, 남은 금액은 17 센트입니다.
3. 17 센트에서 10 센트를 선택하고, 나머지 7 센트는 5 센트와 1 센트 동전으로 구합니다.

이와 같이 탐욕적으로 각 단계에서 가능한 최대 동전을 선택하는 방식은 항상 최소 개수의 동전을 사용하게 됩니다.

## 3.5 정렬 알고리즘

정렬 문제는 데이터 구조나 응용 프로그램에서 자주 사용되며, 다양한 정렬 알고리즘이 존재합니다. 버블 정렬, 삽입 정렬, 선택 정렬, 병합 정렬, 퀵 정렬 등이 주요 알고리즘입니다.

### 선택 정렬 (Selection Sort)

선택 정렬은 리스트에서 최솟값을 찾아 리스트의 앞부분부터 차례로 정렬하는 방식입니다.

#### Pseudocode: 선택 정렬 알고리즘

```r
procedure selection_sort(a₁, a₂, ..., aₙ: real numbers)
    for i := 1 to n-1
        min_index := i
        for j := i+1 to n
            if aⱼ < aₘᵢₙ_ᵢₙdₑₓ then
                min_index := j
        swap(aᵢ, aₘᵢₙ_ᵢₙdₑₓ)
```

### 병합 정렬 (Merge Sort)

병합 정렬은 **분할 정복**(Divide and Conquer) 기법을 사용하여 리스트를 반으로 나누고, 각각을 재귀적으로 정렬한 후 병합하는 방식입니다.

#### Pseudocode: 병합 정렬 알고리즘

```r
procedure merge_sort(a₁, a₂, ..., aₙ: real numbers)
    if n > 1 then
        mid := ⌊n/2⌋
        L := a₁, a₂, ..., aₘᵢ₈
        R := aₘᵢ₈₊₁, ..., aₙ
        merge_sort(L)
        merge_sort(R)
        merge(L, R, a₁, a₂, ..., aₙ)

procedure merge(L: array, R: array, a: array)
    i := 1, j := 1, k := 1
    while i ≤ length(L) and j ≤ length(R)
        if L[i] ≤ R[j] then
            a[k] := L[i]
            i := i + 1
        else
            a[k] := R[j]
            j := j + 1
        k := k + 1
    while i ≤ length(L)
        a[k] := L[i]
        i := i + 1
        k := k + 1
    while j ≤ length(R)
        a[k] := R[j]
        j := j + 1
        k := k + 1
```

## 3.6 최적화 문제

최적화 문제는 **목적 함수**를 최소화하거나 최대화하는 문제로, 탐욕 알고리즘이나 동적 프로그래밍을 사용하여 해결할 수 있습니다.

### 동적 프로그래밍 (Dynamic Programming)

동적 프로그래밍은 큰 문제를 작은 문제로 나누어 해결한 결과를 저장하여 동일한 문제를 반복해서 풀지 않는 방식입니다. 이를 통해 중복 계산을 피하고 효율성을 높일 수 있습니다.

#### 예시: 피보나치 수열 (Fibonacci Sequence)

피보나치 수열을 동적 프로그래밍으로 계산하는 방법은 각 계산 결과를 메모이제이션하여 중복 계산을 줄이는 것입니다.

#### Pseudocode: 동적 프로그래밍을 사용한 피보나치 수열 계산

```r
procedure fibonacci(n: integer)
    if n = 0 or n = 1 then
        return n
    memo := array of size n
    memo[0] := 0
    memo[1] := 1
    for i := 2 to n
        memo[i] := memo[i-1] + memo[i-2]
    return memo[n]
```

## 3.7 정리

이 단원에서는 알고리즘의 정의와 속성, 다양한 알고리즘 문제 해결 방법을 다루었습니다. 특히, 탐색, 정렬, 최적화 문제에 대한 알고리즘과 이들의 동작 방식을 pseudocode와 함께 살펴보았습니다. 알고리즘의 효율성을 높이기 위해선 문제의 성격에 맞는 최적의 알고리즘을 선택하는 것이 중요합니다.
