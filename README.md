# FINAL EXAM

## Chapter 6 : COUNTING, 경우의 수

### 1. The Basics of Counting : 곱의 법칙, 합의 법칙
다들 알겠지 뭐...

### 2. The Pigeonhole Principle : 비둘기집의 원리(PHP)
$k$개 방에 $k+1$마리 비둘기가 들어가면 최소 한 방에는 두마리 이상이 같이 있다.

### 3. Permutations and Combinations : 순열과 조합
$n$개의 원소 중 $k$개의 원소를 중복하지 않게 순서를 가지고 뽑는 경우의 수

$$ {_nP_k}=P(n, k)=\frac{n!}{k!} $$

$n$개의 원소 중 $k$개의 원소를 중복하지 않게 **순서없이** 뽑는 경우의 수

$$ {_nC_k} = \binom{n}{k} = \frac{n!}{k!(n-k)!} $$

### 4. Binomial Coeffcients and Identities : 이항전개
이항전개

$$ (x+y)^n = \sum_{i=0}^n\binom{n}{i}x^iy^{n-i} $$

파스칼 삼각형 (하키채 공식)

$$ \binom{n+1}{k} = \binom{n}{k-1} + \binom{n}{k} $$

$$ \binom{n+1}{r+1} = \sum_{i=r}^n\binom{i}{r} $$

### 5. Generalized Permutations and Conbinations : 중복순열, 중복조합
$n$개의 원소 중 $k$개의 원소를 **중복을 허용하여** 순서를 가지고 뽑는 경우의 수

$$ {_n\Pi_k} = n^k $$

$n$개의 원소 중 $k$개의 원소를 **중복을 허용하여** **순서없이** 뽑는 경우의 수

$$ {_nH_k} = \binom{n+k-1}{k}=\binom{n+k-1}{n-1}=\frac{(n+k-1)!}{k!(n-1)!} $$

### 6. Generating Permutations and Combinations: 사전순서
대충 사전순 정렬 이런거같은데 뭔지 잘 모르겠음... 근데 뭐가 많지도 않음

---

## Chapter 7 : Discrete Probability, 이산확률

확률 나옴  
앞부분은 몰라도 됨  

---
베이즈 정리 : 조건부 확률 적당히 활용하여 풀면 된다.  
근데 스팸 필터 등의 예측 모델에서는 스팸일 확률과 아닐 확율을 동일하게 둔다.  
수학적으로 뭔가 이상했는데 예측 모델의 데이터 개수 맞추는거 생각하면 이게 맞다.  

밀러-로빈 소수 테스트  
페르마 소수 테스트를 확률적으로 바꾼거  
$a^{n-1}=1 (\mod n)$ 이걸 a에 많은 수를 넣어가면서 테스트  
$4^{-k}$로 확률이 나타난다고 한다.  
증명은 ppt에 안나옴  

이후에는 기댓값, 분산 나옴  

체비셰프 부등식  
평균에서 $n\sigma$만큼 떨어질 확률이 $\frac{1}{n^2}$이하다  
증명은 $n\sigma$만큼 떨어진 집합을 잡고 그것에 속하는 원소들은 편차가 $V(X)n^2$이상이 된다  
그런데 이것만 계산하면 충분히 보일 수 있다  
<img src=cheb.jpg width=600>  

마코브 부등식
0보다 큰 확률변수에서 값이 커질 확률을 계산한다  
딱히 뭐가 없다  
그냥 평균 가지고 연속적인 값으로 확장한 비둘기집 정도 느낌  

## Chapter 8

점화식 나옴  
특성방정식 나옴  
나머지는 식을 적당히 잘 변형시키면 된다  
이건 고등학교에서 배운거  

분할정복  
포함배제  

---
생성함수  
<img src=genfunc.png width=600>  
대충 이 형태가 되는 다항식을 생성하는 방법에 대해 좀 고민하면 된다  
이렇게 하면 적당한 x 범위에서 무한급수 꼴이 나오게 할 수도 있어서 유용한 경우가 있다  
지수 생성함수는 저걸 k!로 나눠서 더한거  
곱하거나 더할때 유용하다  

0, 1, 2로만 이루어져 있고 0의 개수가 짝수인 길이 n의 수열 구하는 문제  
0의 개수가 짝수라는 말은 $1+x^2+x^4+...=\frac{1}{1-x^2}$  
나머지는 상관없으니까 $1+x+x^2+x^3+...\frac{1}{1-x}$

이걸 다 곱하면 뭔가 나오긴 하겠지만 모양이 아주 빡세 보인다.  
이럴 경우 지수 생성 함수를 사용하면 뭔가 편한 모양이 나온다.  
여러 개의 곱으로 나타낼 때 그냥 생성함수 써버리면 이렇게 힘든 모양이 나와서 지수를 사용한다.  

$\frac {1}{2} (e^{-x}+e^x)e^xe^x=\sum^{∞}_{n=0}\frac {3^n+1}{2}\frac{x^n}{n!}$  

그냥 생성 함수보다 더 쉽게 결과를 얻을 수 있다. $\frac {3^n+1}{2}$  
근데 솔직히 의미가 있나 싶은게 그냥 점화식 만들고 풀면 된다.  


## Chapter 10

gpt의 용어 정리
1. **Graph**: 그래프  
   - 점(노드, vertex)과 선(엣지, edge)으로 이루어진 구조.

2. **Vertex (Vertices)**: 정점 (복수형: Vertices)  
   - 그래프에서 연결된 점, 노드라고도 부름.

3. **Edge**: 간선 (엣지)  
   - 두 정점을 연결하는 선.

4. **Loop**: 루프  
   - 하나의 정점에서 시작해 다시 그 정점으로 돌아오는 간선.

5. **Degree**: 차수  
   - 한 정점에 연결된 간선의 개수.

6. **Path**: 경로  
   - 시작 정점에서 끝 정점까지의 연결된 간선들의 연속.

7. **Circuit**: 회로  
   - 경로 중에서 시작과 끝이 같은 경우.

8. **Simple Graph**: 단순 그래프  
   - 루프와 중복된 간선이 없는 그래프.

9. **Multigraph**: 멀티그래프  
   - 동일한 두 정점 간에 여러 간선이 있을 수 있는 그래프.

10. **Directed Graph**: 방향 그래프  
    - 간선에 방향성이 있는 그래프.

11. **Adjacency Matrix**: 인접 행렬  
    - 정점 간의 연결 관계를 0과 1로 표시한 행렬.

12. **Incidence Matrix**: 발생 행렬  
    - 정점과 간선 간의 관계를 나타내는 행렬.

13. **Connected Graph**: 연결 그래프  
    - 그래프의 모든 정점들이 서로 경로로 연결된 상태.

14. **Euler Path/Circuit**: 오일러 경로/회로  
    - 모든 간선을 한 번씩만 지나가는 경로(경우에 따라 시작과 끝이 같으면 회로).

15. **Hamiltonian Path/Circuit**: 해밀턴 경로/회로  
    - 모든 정점을 한 번씩만 방문하는 경로(회로는 시작과 끝이 같음).

16. **Isomorphic Graphs**: 동형 그래프
    - 두 그래프 G1, G2에 대해 G1의 정점들과 G2의 정점들 사이에 전단사 함수 f가 존재하여, G1의 임의의 두 정점 u,v가 연결되어 있다면 f(u),f(v)도 연결되어 있고 그 역도 성립하는 경우를 말함.

이정도만 알면 딱히 어려운 내용은 없다

## Chapter 11
트리 : 회로가 없는 연결 그래프

Forest : simple circuit이 없는 그래프  
연결되어 있을 필요는 없다  

트리에서 임의의 두 정점을 잡았을 때 그 두 정점을 잇는 경로는 유일하다.  
증명 : 두 정점 u,v를 잇는 경로가 두 개 있다고 가정하자.  
u에서 v로 가는 경로를 P1, 반대 방향으로 v에서 u로 가는 경로를 P2라고 하자.  
P1과 P2는 서로 교차하지 않는 두 경로라면 두 경로를 이어붙이면 회로가 되어 트리 조건에 모순이다.  
교차하는 점이 존재한다면 그 점을 기준으로 두 경로를 이어붙이면 회로가 된다.  

rooted tree : 트리에서 하나의 정점을 선택하여 그 정점을 루트로 하는 트리

---

### Rooted Tree Terminology

1. **Parent(부모)**: 직접 연결된 자식 노드를 하나 이상 가진 노드
2. **Child(자식)**: 부모 노드와 직접 연결되어 있고 한 단계 아래에 있는 노드
3. **Siblings(형제)**: 같은 부모를 가진 노드들
4. **Ancestor(조상)**: 루트에서 특정 노드까지의 경로상에 있는 모든 노드, 자기 자신도 포함
5. **Descendant(자손)**: 특정 노드에서 리프까지의 경로상에 있는 모든 노드, 자기 자신도 포함
6. **Leaf(리프)**: 자식이 없는 노드
7. **Internal Node(내부 노드)**: 최소 하나의 자식을 가진 노드
8. **Subtree(서브트리)**: 한 노드와 그 노드의 모든 자손으로 구성된 트리

m-ary tree : 각 노드가 최대 m개의 자식을 가지는 트리  
ordered rooted tree : 자식 노드들이 순서가 있는 트리(동형 판정에서 차이가 존재하고 트리 순회에서 중요함)  

### 트리의 주요 속성과 증명

1. **모든 트리는 최소 하나의 리프 노드를 가진다**

    귀류법으로 증명:
    - 리프 노드가 없다고 가정 (모든 노드가 최소 하나의 이웃을 가짐)
    - 임의의 노드에서 시작하여 계속 이웃으로 이동
    - 유한한 노드(n개)를 가진 트리에서 n+1번째 방문은 반드시 이전 노드를 재방문
    - 이는 회로가 존재한다는 의미이므로 트리의 정의에 모순
    - 따라서 리프 노드는 반드시 존재

2. **n개의 정점을 가진 트리는 n-1개의 간선을 가진다**

    수학적 귀납법으로 증명:
    - n=1일 때 간선은 0개로 성립
    - k개 정점을 가진 트리가 k-1개의 간선을 가진다고 가정
    - k+1개 정점을 가진 트리 T에서:
    - 리프 노드 하나와 그에 연결된 간선을 제거하면 k개 정점을 가진 트리 T'
    - T'는 귀납 가정에 의해 k-1개의 간선
    - 원래 트리 T는 k-1+1 = k개의 간선
    - 이는 (k+1)-1과 같음
    - 따라서 모든 자연수 n에 대해 성립


level : 각 노드에서 루트까지의 거리
height : 루트에서 가장 멀리 떨어진 노드까지의 거리

balanced tree : 모든 리프 노드의 레벨이 h 또는 h-1인 트리



---
트리 순회



